{"pages":[],"posts":[{"title":"","text":"Fiddler的使用及与Charles区别官方网站： https://www.telerik.com/fiddler 官网下载地址： https://www.telerik.com/download/fiddler 简介：Fiddler是位于客户端和服务器端之间的代理，也是目前最常用的抓包工具之一 。它使用代理地址:127.0.0.1，端口:8888。能够记录客户端和服务器之间的所有请求，可以针对特定的请求，分析请求数据、设置断点、调试web应用、修改请求的数据，甚至可以修改服务器返回的数据，功能非常强大，是web调试的利器。 fiddler抓包原理 配置Web 端配置： 配置浏览器：当启用fiddler为代理时，部分浏览器会提示风险，如Firefox ； 此时可以在浏览器设置里面设置手动代理： 127.0.0.1 端口为 8888， 可以避开风险提示； 可以通过设置解决 ： Firefox： 设置 - 常规 - 网络设置 - 手动代理设置 对于https抓包，可以通过在设置fiddler 解密： Tools -&gt;fiddler options -&gt;HTPPS 中勾选 “Decrypt HTTPS Traffic” 设置信任证书 ： actions : trust_Root_certificate 手机端配置： 设置fiddler 允许远程连接： 手机设置手动代理到fiddler，以IOS 为例： 设置 -&gt;通用 -&gt; 网络 -&gt; wifi wifi设置里面选择手动代理 输入本机ip地址 ， 端口号设为 8888； 对于https抓包，需要手机安装信任证书： 浏览器访问 ：电脑本地IP 地址+ 端口号8888，下载证书 点击下载安装: Fiddler主界面 ： 左侧面板： 主要详细记录每一个请求的详细信息，包含请求结果， Http响应状态，请求地址域名，请求大小，请求响应的类型等。 右侧面板： 依据功能需要，右侧提供了分析详细请求数据，查看具体的请求信息， 以及抓取在线页面进行web 调试，修改服务器返回值等。 常用功能： 查看接口具体的会话内容 应用场景： 需要进行接口定位； 操作步骤： 一般测试时当前端报错，需要观察报错接口时，可以使用fiddler 抓包， 查看具体报错原因； 记录接口的详细请求数据，当需要反复调试接口时，使用这些数据在postman 进行调试，快速定位问题是否已经被解决； 模拟慢网速的情况 应用场景：有时候因为网络波动导致一些异常报错， 需要复现 操作步骤： Fiddler 限速通过延迟发送或接收数据的时间来限制网络的下载和上传速度，从而限速。 使用rules -&gt; performance-&gt; Simulate Modem Speeds 限速时的情况（以下是http://www.speedtest.cn/ 网站测速） 采用默认的不一定符合要求，可以采用自定义配置限速参数：右侧监控面板“FiddlerScript”选项卡 -&gt; find 中输入“m_Simulate” 修改其中相应的请求，响应延迟，单位ms. 不限速时的情况： PS : Fiddler 模拟慢网速的情况相比较于Charles 来说，Charles 效果更显著些，当fiddler 效果不明显时建议使用Charles Charles模拟慢网速使用方法： proxy -&gt; Throtting setting 中： mock数据： 应用场景：需要测试一些异常的case，需要更改任意请求参数 或者响应参数时， 比如前端做了限制不允许输入 操作步骤： 选中我们需要mock的会话 -&gt; 保存服务器返回body内容在任意文件夹 -&gt; 修改body内容， 在 AutoResponder 中导入 -&gt; 勾选 enable rules ,再次请求 设置断点,快速修改返回参数 ： 应用场景：需要拦截所有的请求， 比上述mock更快捷，但仅适用于一次性请求 操作步骤：1. Rules -&gt; Automatic Breakpoint -&gt;before Request 或者 直接点击会话列表下方的断点按钮； \\2. 修改请求参数后，点击 “break to response “查看响应参数 ； \\3. 点击”run to completion“ 查看web端调试结果 重复请求会话 应用场景：网络中断或者需要进行简单的性能测试，频繁调用同一接口 操作步骤：右击选中的请求 -》 replay -》Reissue sequentially -》设置一次请求的次数 PS： 对比Charles， Charles也可以设置重复请求： Fiddler 抓取不到包的原因： 一般来说，打开fiddler 就是抓包状态，如果没有开始抓包见下； 首先确定一下 file-&gt;capture traffic 这个是否勾选—》即页面左下角capturing 是否打开； 如果访问的网站是https网站， 则可以通过Tools - Fiddler Options - Https - Decrypt Http Traffic来设置将https解密； 依然抓不到包，查看是否安装了正确的https证书 手机客户端请求抓不到的原因（这个Charles 与之基本类似）： 是否在同一局域网内； 是否有防火墙拦截； Fiddler(charles) 是否允许远程客户端连接； 监听端口号是否是默认的8888； IOS 手机设置信任证书： 设置 - 通用 - 关于本机 - 证书信任设置 中手动设置信任证书； Fiddler 和Charles: 共同点：抓包，断点调试，请求替换，代理功能 不同点：Charles是收费的，但可以在各大主流平台都可以使用； Fiddler开源免费， 但只能在windows上运行；","link":"/2021/08/08/Fiddler%20vs%20charles/"},{"title":"Ubuntu升级python及设置默认版本","text":"ubuntu 升级 python 2.7 - python 3.6 查询一般办法： 添加安装源ppa： sudo add-apt-repository ppa:jonathonf/python-3.6 加入python3.6 安装源进入系统后，更新软件列表： sudo apt-get update 更新安装源后，安装python3.6： sudo apt-get install python3.6 ​ 报错之后可以采用： sudo add-apt-repository ppa:deadsnakes/ppa 继续执行： sudo apt-get update sudo apt-get install python3.6 依然不成功的话： 可以查看是否系统配置有问题， 或者因为网络原因导致更新源没有更新成功，切换网络试试。 安装完成之后， 接下来设置python3.6的优先级和默认： 调整python3 的优先级： sudo update-alternatives –install /usr/bin/python3 python3 /usr/bin/python3.5 1 sudo update-alternatives –install /usr/bin/python3 python3 /usr/bin/python3.6 2 注： –install 选项使用多个参数用于创建符号链接，最后一个参数指定了此选项的优先级，优先级高的选项会被选中。 此例子中， 因为python3 /usr/bin/python3.6 设置的优先级为2， 所以在update-alternatives命令会在 /usr/bin/python3 版本下自动将python3.6 设置为 python3 默认版本。 设置默认版本 更改python默认，系统默认为python 2，现更改为python3： sudo update-alternatives –install /usr/bin/python python /usr/bin/python2 100 sudo update-alternatives –install /usr/bin/python python /usr/bin/python3 150 注： 此例设置python 2 和 python 3 的优先级，这里python 3 在/usr/bin/python 中优先级更高，所以默认python3 系统切换默认版本： ~$ update-alternatives –list python # 列出所有可用的python替代版本信息 /user/bin/python2 /user/bin/python2 ~$ python –version #查看默认python版本 python 3.6.10 切换默认版本到python2 ~$ sudo update-alternatives –config python lvxiran@lvxiran-virtual-machine:~$ sudo update-alternatives --config python [sudo] lvxiran 的密码： 有 2 个候选项可用于替换 python (提供 /usr/bin/python)。 选择 路径 优先级 状态 ------------------------------------------------------------ * 0 /usr/bin/python3 150 自动模式 1 /usr/bin/python2 100 手动模式 2 /usr/bin/python3 150 手动模式 要维持当前值[*]请按&lt;回车键&gt;，或者键入选择的编号：1 update-alternatives: 使用 /usr/bin/python2 来在手动模式中提供 /usr/bin/python (python) 再次查看python 默认版本已经变成 python2 了 更优的解决办法： ##有关virtualenv 详见 《virtuale环境和flask安装》 安装virtualenv ,实现不同版本之间的切换 mkdir venvflask #新建一个项目文件夹 cd venvflask #进入到该文件夹下 已经安装pip： pip install virtualenv 未安装pip： sudo apt-get install python-virtualenv 创建一个虚拟环境： virtualenv venv 创建一个python包之间没有关联的虚拟环境： virtualenv –no-site-packages venv 激活虚拟环境： source venv/bin/activate 切换Python版本工作时： cd ~/path/to/project #进入项目文件夹 source ~/venvflask/venv/bin/activate #切换到虚拟环境中python版本工作","link":"/2020/03/10/Uuntu%E5%8D%87%E7%BA%A7python%E7%89%88%E6%9C%AC/"},{"title":"python","text":"with: 基本语法格式： with exp [as target]; target 可以是变量或者元组，存储exp返回的结果； With是一种上下文管理协议，其表达式其实是try - finally 的简写形式，但没有except 功能； 使用with处理的对象必须包含方法 enter()和exit()； enter()在方法体执行前运行，初始化代码块，并将返回值赋值给as关键字后的变量; exit() 在方法体执行结束后运行，关闭代码块，释放资源，如文件使用后关闭等。即便代码块抛出异常也调用exit() 退出代码块。 工作原理代码示意 #encoding = utf - 8 class Mytest(): def __init__(self,file_name): self.file_name = file_name def __enter__(self): print(&quot;进入__enter__&quot;) self.f_name = open(self.file_name) return self.f_name def __exit__(self, exc_type, exc_val, exc_tb): print(&quot;进入__exit__&quot;) self.f_name.close() with Mytest(&quot;1.txt&quot;) as f: for line in f.readlines(): print(line.strip()) 输出结果： 进入__enter__ YYYYYYYYYYYYYYYYYY LLLLLLLLLLLL MMMMMMMM 进入__exit__ 将上述代码中执行代码块更改一下： try: with Mytest(&quot;1.txt&quot;) as f: context = f.readlines() print('------') except FileNotFoundError: print(&quot;该文件不存在&quot;) else: for line in context: print(line.strip()) 输出结果： 进入__enter__ ------ 进入__exit__ YYYYYYYYYYYYYYYYYY LLLLLLLLLLLL MMMMMMMM Process finished with exit code 0","link":"/2021/08/08/python_with/"},{"title":"","text":"日常小记《virtual环境和flask安装》virtualenv : 解决需要切换多版本python运行的问题. virtualenv就是用来为一个应用创建一套“隔离”的Python运行环境. 首先： $ pip3 install virtualenv 然后 第一步，创建目录 Mac:~ michael$ mkdir myproject Mac:~ michael$ cd myproject/ Mac:myproject michael$ 第二步，创建一个独立的python运行环境 virtualenv envname Mac:myproject michael$ virtualenv –no-site-packages venv 新建的python 环境会被放到venv目录下， 用source 进入该环境 (linux) Mac:myproject michael$ source venv/bin/activate (windows) venv\\Scripts\\activate.bat 在venv环境下，用pip安装的包都被安装到这个环境； pip install flask 退出当前的venv环境， 用deactivate (linux) (venv)Mac:myproject michael$ deactivate (windows) venv\\Scripts\\deactivate.bat 检测安装版本： pip3 freeze (venv) lvxiran@lvxiran-virtual-machine:~/venvflask$ pip3 freeze Click==7.0 Flask==1.1.1 itsdangerous==1.1.0 Jinja2==2.11.1 MarkupSafe==1.1.1 Werkzeug==1.0.0","link":"/2021/08/08/virtual_flask/"},{"title":"","text":"学习笔记一《selenium 基本原理》Selenium 的简介： Selenium1.0 ： Selenium core = Selenium Remote Control (RC )+ Selenium IDE (集成开发环境） Selenium 2.0 : = Selenium1 + WebDriver Webdriver 用来绕过JavaScript环境的沙盒限制， 可以直接让测试工具调用浏览器和操作系统本身提供的内置方法。 Selenium 官网地址： www.seleniumhq.org Selenium RC 的实现原理 selenium1的自动化执行步骤： 测试人员基于Selenium支持的编程语言编写好测试脚本程序。 测试人员执行测试程序。 测试脚本程序发送访问网站的HTTP请求给Remote Control Server（RC）。 RC 收到请求后，访问被测试网站并获取网页数据内容，并在网页中插入Selenium Core的JavaScript代码库，然后返回给测试人员执行测试的浏览器。 测试脚本在浏览器内部再调用selenium Core来执行测试代码逻辑，记录测试结果，完成测试 理解以上步骤： 理解“ 同源策略” —-浏览器的JavaScript 安全机制 相同的协议，端口，域名 Selenium 1工具的核心部分是基于JavaScript代码库来实现的，这个库默认地和被测网站分离，它的URL和被测网站的域名是不一致的，为了绕过浏览器安全机制，Selenium 1.0 作者使用代理方式解决问题 selenium1代理模式的实现机制： 执行测试脚本，脚本向Selenium Server发起请求，要求和Selenium Server建立链接。 Selenium Server的Launcher启动浏览器，向浏览器中插入Selenium Core的JavaScript代码库，并把浏览器的代理设置为Selenium Server的Http Proxy，确保后续Core的脚本域被访问的网站的脚本同源。 测试脚本向seleniumServer发送Http请求，Selenium Server对请求进行解析，然后通过Http Proxy发送JS命令通知Selenium Core发送JS命令通知Seleniim Core执行操作浏览器的请求。 Selenium Core收到指令后，执行测试脚本里指定的网页操作命令。 浏览器收到新的请求信息，于是发送Http请求给Selenium给Selenium Core里的Http Proxy，请求新的Web页面。（因为第二步中，selenium Server在启动浏览器的时候，已经把浏览器的代理地址设定为Selenium Server的Http Proxy） Selenium Server接收到请求后，自行重组http请求，向应用服务器发送请求并获取返回的web页面。 Selenium Server的Http Proxy把接收到的Web页面返回给浏览器。 WebDriver 的实现原理 与 selenium 1注入不同，直接利用浏览器的内部接口来操作浏览器； 优点： 基于浏览器内部接口实现自动化测试，接近用户使用的真实情况； selenium必须操作浏览器，webdriver 可以使用HTMLunit进行测试，不打开浏览器进行快速测试 提供了简介的面向对象API ， 提高测试脚本的编写效率 使用过程中无须单独启动selenium server","link":"/2021/08/08/selenium/selenium01/"},{"title":"","text":"学习笔记二《Selenium IDE》Selenium IDE： Selenium IDE仅作为Mozilla Firefox和Chrome插件提供，可实现网页操作步骤的录制和回放， 执行简单测试逻辑的自动化测试， 可以将录制的测试脚本导出为C#，Java，Ruby或Python等编程语言 主界面如图： 常用工具栏**： 从左到右依次是： 执行所有case按钮， 执行当前case按钮，单步执行按钮，测试用例执行速度控制栏， 断点， 暂停录制，录制脚本按钮 Selenium IDE脚本介绍： Commond 命令也成为selenese; Selenese 最多有两个参数（target 和 value ),也可以有一个（target） 或者没有参数； Selenese 命令类型： Actions 类型： 如click 命令表示单击页面元素； type命令会在页面文本框输入文字，输入的内容显示在文本框中 Accessors 存储器类型： 如storeTitle存储型命令，将页面的title信息读取出来，并存储到变量中，与页面元素本身没有交互 Assertions断言类型： 如 Assert， Verify，waitFor 部分验证点操作： 选中一个验证点， 编辑脚本中可以更改验证点： “右键” 插入一个新的command， 查看编辑脚本区，列表展示合适的验证点 以上录制脚本中： case全部通过， 左下角显示绿色进度条说明case通过； 如果没有通过，则显示红色提示，说明失败case; 已经跑完通过的case在脚本显示区为绿色 未执行完成的case为黄色 尚未执行的case为灰色 执行失败的case为红色 tips： Selenium IDE：学习此插件需要熟悉HTML, JavaScript, DOM Selenium IDE 仅适用于执行简单逻辑的自动化测试脚本，不适用大项目","link":"/2021/08/08/selenium/selenium02/"},{"title":"","text":"学习笔记三《初识WebDriver》 WebDriver原理： Selenium Webdriver是通过各种浏览器的驱动（web driver）来驱动浏览器，原理示意图如下： 在python中安装WebDriver： 完成python，pip工具的安装后，在cmd下输入“pip install selenium”， 完成安装后输入”python” 进入python 交互模式， 输入“import selenium” 没有报错即成功安装selenium。 安装浏览器驱动： Firefox 浏览器的驱动： https://github.com/mozilla/geckodriver/releases Google浏览器驱动： http://npm.taobao.org/mirrors/chromedriver/ 选择适合自己操作系统的版本进行下载。 第一个webDriver 脚本： #-*-coding:UTF-8-*- fromseleniumimportwebdriver fromselenium.common.exceptionsimportNoSuchElementException importtime importselenium.webdriver.support.uiasui #通过executable_path参数指明Firefox驱动文件所在路径 #路径查询：windows系统或者采用C:/Users/34954/Downloads/geckodriver driver=webdriver.Firefox(executable_path=&quot;C:\\\\Users\\\\34954\\\\Downloads\\\\geckodriver&quot;) #若定位元素时间较长，可用10s内每隔500ms扫描1次页面变化，当出现指定元素后结束 wait=ui.WebDriverWait(driver,10) #打开百度首页 driver.get(&quot;https://baidu.com&quot;) try: wait.until(lambdadriver:driver.find_element_by_id(&quot;kw&quot;)) #清空搜索输入框默认内容 driver.find_element_by_id(&quot;kw&quot;).clear() #在搜索输入框内输入“自动化测试” driver.find_element_by_id(&quot;kw&quot;).send_keys(&quot;自动化测试&quot;) #单击“搜索”按钮 driver.find_element_by_id(&quot;su&quot;).click() #若定位不到元素，抛出异常 exceptNoSuchElementExceptionasmsg: print(&quot;查找元素异常&quot;) #等待3秒 time.sleep(3) #退出浏览器 driver.quit() 4.1 问题及建议 问题 1. 报错提示NoSuchElementException: Unable to locate element 解决办法： 去网页相应的元素下查找相关的element_id， 如url为sogou.com时对应的查询id为“query”，对应的搜索button id为“stb”","link":"/2021/08/08/selenium/selenium03/"}],"tags":[{"name":"ubuntu","slug":"ubuntu","link":"/tags/ubuntu/"},{"name":"python","slug":"python","link":"/tags/python/"}],"categories":[{"name":"python","slug":"python","link":"/categories/python/"}]}